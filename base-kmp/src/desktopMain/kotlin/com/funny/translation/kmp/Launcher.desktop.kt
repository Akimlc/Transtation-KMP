package com.funny.translation.kmp

import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import com.eygraber.uri.Uri
import com.funny.translation.helper.Log
import com.funny.translation.helper.toastOnUi
import java.awt.FileDialog
import java.awt.Frame
import java.io.File
import java.io.FilenameFilter

actual class FileLauncher<Input>(val onResult: (Uri?) -> Unit): Launcher<Input, Uri?>() {
    actual override fun launch(input: Input) {
        val dialog = FileDialog(null as Frame?, "Choose a file", FileDialog.LOAD)

        when (input) {
            is String -> {
                // String 为文件名，对应创建文件
                dialog.file = input
            }
            is Array<*> -> {
                // Array<String> 多种文件类型，对应选择文件
                val mimes = input.filterIsInstance<String>()
                dialog.filenameFilter = FilenameFilter { file, s ->
                    if (file != null) {
                        val fileName = file.name
                        val fileSuffixes = mimes.flatMap { mimeToSuffixList(it) }.distinct()
                        return@FilenameFilter fileSuffixes.any { suffix ->
                            return@any fileName.endsWith(".$suffix")
                        }
                    }
                    return@FilenameFilter false
                }
            }
            else -> {
                // 其他类型，可以根据需要进行处理
            }
        }

        dialog.isVisible = true

        val selectedFile = dialog.file
        if (selectedFile != null) {
            val filePath = "${dialog.directory}${File.separator}$selectedFile"
            Log.d("FileLauncher", "selected filePath: $filePath")
            onResult(Uri.fromFile(filePath))
        } else {
            onResult(null)
        }
    }
}


actual class MultiFileLauncher<Input>(
    val onResult: (List<String>) -> Unit
) : Launcher<Input, List<String>>() {
    actual override fun launch(input: Input) {
        val dialog = FileDialog(null as Frame?, "Choose files", FileDialog.LOAD)

        if (input is Array<*> && input.isArrayOf<String>()) {
            val mimes = input.filterIsInstance<String>()
            val fileSuffixes = mimes.flatMap { mimeToSuffixList(it) }.distinct()
            Log.d("MultiFileLauncher", "mimes: $mimes, suffixes: $fileSuffixes")
            dialog.filenameFilter = FilenameFilter { file, s ->
                if (file != null) {
                    val fileName = file.name

                    return@FilenameFilter fileSuffixes.any { suffix ->
                        return@any fileName.endsWith(".$suffix")
                    }
                }
                return@FilenameFilter false
            }

            // 显示一个提示框，告知用户当前正在过滤的文件类型
            val message = "可选择文件类型: ${fileSuffixes.joinToString(", ")}"
            javax.swing.JOptionPane.showMessageDialog(null, message, "文件类型过滤", javax.swing.JOptionPane.INFORMATION_MESSAGE)
        }

        dialog.isMultipleMode = true
        dialog.isVisible = true
        val files = dialog.files
        if (files != null) {
            val filePaths = files.map { "file://" + it.absolutePath }
            Log.d("MultiFileLauncher", "selected filePaths: $filePaths")
            onResult(filePaths)
        } else {
            onResult(emptyList())
        }
    }
}


@Composable
actual fun rememberCreateFileLauncher(
    mimeType: String,
    onResult: (Uri?) -> Unit
): FileLauncher<String> {
    return remember(mimeType) { FileLauncher(onResult) }
}

@Composable
actual fun rememberOpenFileLauncher(
    onResult: (Uri?) -> Unit
): FileLauncher<Array<String>> {
    return remember { FileLauncher(onResult) }
}

// generated by Github Copilot
private fun mimeToSuffixList(mimeType: String) = when (mimeType) {
    "image/*" -> listOf("jpg", "jpeg", "png", "gif", "bmp")
    "audio/*" -> listOf("mp3", "wav", "ogg", "m4a", "aac", "flac")
    "video/*" -> listOf("mp4", "avi", "mkv", "mov", "flv", "f4v", "m4v", "rmvb", "rm", "3gp", "dat", "ts", "mts", "vob")
    "text/*" -> listOf("txt", "log", "xml", "html", "htm", "css", "js", "json", "java", "kt", "c", "cpp", "h", "hpp", "py", "sh", "bat", "md")
    "application/*" -> listOf("apk", "exe", "doc", "docx", "xls", "xlsx", "ppt", "pptx", "pdf", "zip", "rar", "7z")
    else -> listOf(mimeType.split("/").last())
}


@Composable
actual fun rememberTakePhotoLauncher(onResult: (Boolean) -> Unit): Launcher<String, Boolean> {
//    error("Taking photo is not implemented on Desktop")
    return object : Launcher<String, Boolean>() {
        override fun launch(input: String) {
            appCtx.toastOnUi("Taking photo is not implemented on Desktop")
        }
    }
}